#+title: Stupid config for stupid people
#+author: Ilnar Gazizov (iigaz)
#+description: Stupid config for stupid people.
#+options: toc:3

#+begin_example

         /*\           /*\         
        /---\_       _/---\        
        (-\---\     /---/-)        
        |--\-\-\___/-/-/--|        
        ]-\-_--*****--_-/-[        
        ]--/∙∙∙∙∙∙∙∙∙∙∙\--[        
        >-(∙∙∙∙∙∙∙∙∙∙∙∙∙)-<        
        /_[∙∙∙∙∙∙∙∙∙∙∙∙∙]_\        
        * [∙∙,^∙∙∙∙∙^.∙∙] *        
         ][∙(__\_∙_/__)∙][         
         ]\∙|\_/ v \_/|∙/[         
         </\|    ‿    |/->         
          \_v--.___.--,^/          
           /-~| >v< |~-_\          
         -- _\]*"-"*[/_  -         
        (__/-‘---------‘-_)        
         _/’,~~~.--,/~~.~‘\        
        (∙∙∙__∙∙∙\/∙∙__∙∙∙)        
        *--(..\_____/..)--*        
           \__/     \__/

#+end_example

* Table of Contents                                                     :TOC:
- [[#essential][Essential]]
  - [[#package-management][Package management]]
  - [[#customize][Customize]]
  - [[#basic-keybindings][Basic keybindings]]
  - [[#window-management][Window management]]
  - [[#custom-functions][Custom functions]]
  - [[#input-fixes][Input fixes]]
  - [[#flyspell][Flyspell]]
  - [[#editor-behaviour][Editor behaviour]]
  - [[#undoredo][Undo/Redo]]
  - [[#multiple-cursors][Multiple cursors]]
  - [[#dired][Dired]]
  - [[#org-mode][Org mode]]
  - [[#markdown][Markdown]]
  - [[#magit][Magit]]
  - [[#session-management][Session management]]
  - [[#helpful-niceties][Helpful niceties]]
  - [[#miscellaneous][Miscellaneous]]
- [[#cosmetic-fixes][Cosmetic fixes]]
  - [[#general][General]]
  - [[#icons][Icons]]
  - [[#mode-line][Mode line]]
  - [[#minibuffer-and-completion][Minibuffer and completion]]
  - [[#editing-niceties][Editing niceties]]
- [[#themes][Themes]]
  - [[#select-light--dark-theme-based-on-system-theme][Select light / dark theme based on system theme]]
- [[#other-packages][Other packages]]
  - [[#terminal][Terminal]]
  - [[#format-on-save][Format on save]]
  - [[#company][Company]]
  - [[#flycheck][Flycheck]]
  - [[#avy][Avy]]
  - [[#directory-browser][Directory browser]]
  - [[#restclient][Restclient]]
  - [[#bells-and-whistles][Bells and whistles]]
- [[#customizations][Customizations]]
- [[#notes][Notes]]

* Essential

** Package management

I'll use the default emacs package manager, with third party
package repository MELPA (which claims to be the biggest emacs package
repo). For convenience, I'll also install [[https://github.com/jwiegley/use-package][use-package macro]] for
managing package configurations.

#+begin_src emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (package-initialize)

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

** Customize

Emacs stores customizations done with =customize= commands along with
a list of *selected* packages in init file by default. This is not
obvious, and sometimes messes up customizations.

I really don't recommend using =customize=, and instead write everything
in =use-package :custom=, but if you really need to use it, this code
moves them to another file (~customize.el~) and loads it before any
configurations with =use-package= are called.

#+begin_src emacs-lisp
  ;; File to store customizations done with 'customize'
  (setq custom-file (concat user-emacs-directory "customize.el"))
  ;; Load custom file
  (when (file-readable-p custom-file) (load custom-file))
#+end_src

** Basic keybindings

I don't like default emacs keys and don't want to learn vim.
I don't like cua-mode either. The best alternative I've found is
[[https://github.com/darkstego/wakib-keys/][wakib-keys]]. They make it easy to switch between text editors,
replacing traditional emacs keybindings with more conventional
ones, at the cost of moving key prefixes from C-c to C-d and from C-x
to C-e. I further customized them, more or less taking inspiration
from vscode, with some functions hacked together from various
snippets I've taken on the internet.

#+begin_src emacs-lisp
  (use-package wakib-keys
    :init
    (defun wakib-custom-copy-without-region ()
      "Copy region if there is any, and copy the whole line otherwise."
      (interactive)
      (if (use-region-p)
          (kill-ring-save (region-beginning) (region-end))
        (kill-whole-line)
        (yank)))

    (defun wakib-custom-cut-without-region ()
      "Cut region if there is any, and cut the whole line otherwise."
      (interactive)
      (when (use-region-p)
        (kill-region (region-beginning) (region-end))))

    (defvar wakib-custom-protected-buffer-list '("*scratch*" "*dashboard*" "*Messages*")
      "Buffers defined in this list won't be killed with `wakib-custom-kill-buffer', and will be buried instead.")

    (defun wakib-custom-kill-buffer ()
      "Bury current buffer if it is in `wakib-custom-protected-buffer-list', and kill it otherwise."
      (interactive)
      (if (member (buffer-name (current-buffer)) wakib-custom-protected-buffer-list)
          (bury-buffer)
        (kill-buffer (current-buffer))))

    (defun wakib-custom-delete-word (arg)
      "Delete characters forward until encountering the end of a word.
      With argument, do this that many times.
      This command does not push text to `kill-ring'."
      (interactive "p")
      (delete-region
       (point)
       (progn
         (forward-same-syntax arg)
         (point))))

    (defun wakib-custom-backward-delete-word (arg)
      "Delete characters backward until encountering the beginning of a word.
      With argument, do this that many times.
      This command does not push text to `kill-ring'."
      (interactive "p")
      (wakib-custom-delete-word (- arg)))

    (defun wakib-custom-delete-line ()
      "Delete text from current position to end of line char.
      This command does not push text to `kill-ring'."
      (interactive)
      (delete-region
       (point)
       (progn (end-of-line 1) (point)))
      (delete-char 1))

    (defun wakib-custom-delete-line-backward ()
      "Delete text between the beginning of the line to the cursor position.
      This command does not push text to `kill-ring'."
      (interactive)
      (let (p1 p2)
        (setq p1 (point))
        (beginning-of-line 1)
        (setq p2 (point))
        (delete-region p1 p2)))

    (defun wakib-custom-quit ()
      "Smart quit, takes windows and daemonp into an account."
      (interactive)
      (if (eq (selected-window) (window-main-window (selected-frame)))
          (if (daemonp)
              (delete-frame)
            (when (yes-or-no-p "Are you sure you want to quit GNU Emacs? ")
              (save-buffers-kill-terminal)))
        (delete-window)))

    (defun wakib-custom-switch-to-last-buffer ()
      "Switches to last buffer."
      (interactive)
      (switch-to-buffer nil))

    (setq wakib-keylist
          `(("M-j" . left-char)
            ("M-l" . right-char)
            ("M-i" . previous-line)
            ("M-k" . next-line)
            ("M-u" . backward-word)
            ("M-o" . forward-word)
            ("M-a" . wakib-back-to-indentation-or-beginning) ;; reminiscent of regular Emacs C-a
            ("M-e" . move-end-of-line) ;; reminiscent of regular Emacs C-e
            ("M-[" . backward-paragraph)
            ("M-]" . forward-paragraph)
            ("M-S-i" . scroll-down-command)
            ("M-S-k" . scroll-up-command)
            ("M-n" . beginning-of-buffer)
            ("M-S-n" . end-of-buffer)
            ("C-n" . wakib-new-empty-buffer)
            ("C-o" . find-file)
            ("C-S-o" . revert-buffer)
            ("C-w" . wakib-custom-kill-buffer)
            ("C-q" . wakib-custom-quit)
            ("C-<next>" . next-buffer)
            ("C-<prior>" . previous-buffer)
            ("C-c" . wakib-custom-copy-without-region)
            ("C-x" . wakib-custom-cut-without-region)
            ("C-v" . yank)
            ("C-z" . undo-only)
            ("C-S-z" . undo-redo)
            ("C-y" . undo-redo)
            ("C-f" . isearch-forward)
            ("C-S-f" . isearch-backward)
            ("C-r" . query-replace)
            ("C-S-r" . query-replace-regexp)
            ("C-s" . save-buffer)
            ("C-S-s" . write-file)
            ("C-p" . switch-to-buffer)
            ("C-S-p" . ibuffer)
            ("C-a" . mark-whole-buffer)
            ("C-+" . text-scale-increase)
            ("C-=" . text-scale-increase)
            ("C--" . text-scale-decrease)
            ("C-/" . comment-line)
            ("C-:" . async-shell-command)
            ("M-C-;" . eval-expression)
            ("M-h" . other-window)
            ("M-M" . goto-line)
            ("M-4" . split-window-right)
            ("M-$" . split-window-below)
            ("M-3" . delete-other-windows)
            ("M-#" . delete-window)
            ("M-r" . kill-word)
            ("M-E" . wakib-backward-kill-line)
            ("M-R" . kill-line)
            ("M-w" . kill-whole-line)
            ("M-<f4>" . save-buffers-kill-emacs)
            ("M-d" . delete-backward-char)
            ("M-f" . delete-char)
            ("M-s" . set-mark-command)
            ("M-S-s" . set-rectangular-region-anchor)
            ("M-=" . count-words)
            ("<C-return>" . wakib-insert-line-after)
            ("<C-S-return>" . wakib-insert-line-before)
            ("M-X" . pp-eval-expression)
            ("<C-backspace>" . wakib-custom-backward-delete-word)
            ("<C-delete>" . wakib-custom-delete-word)
            ("<escape>" . keyboard-quit)
            ("<C-tab>" . wakib-custom-switch-to-last-buffer)
            ("C-{" . hs-hide-block)
            ("C-}" . hs-show-block)))
    :config
    (wakib-keys 1))

  (global-set-key (kbd "C-c C-;") 'shell-command)
#+end_src

** Window management

=windmove= is a built-in package that makes it easy to manage
windows. I've also wrote some functions that make simple window
management a breeze for me.

| Keys       | Action                                       |
|------------+----------------------------------------------|
| C-arrows   | Move to adjacent window                      |
| M-S-arrows | Move current buffer to adjacent window       |
| C-s-up     | Merge current window with window above       |
| C-s-down   | Split current window down                    |
| C-s-left   | Merge current window with window on the left |
| C-s-right  | Split current window right                   |
| s-f        | Remove all windows except current            |

#+begin_src emacs-lisp
  ;; Use meta key for windmove
  (windmove-default-keybindings 'meta)

  (defun ig/split-window-right ()
    (interactive)
    (split-window-right)
    (windmove-right))
  (defun ig/merge-window-left ()
    (interactive)
    (let ((buffer (window-buffer)))
      (windmove-left)
      (windmove-delete-right)
      (set-window-buffer (selected-window) buffer)))
  (defun ig/split-window-down ()
    (interactive)
    (split-window-below)
    (windmove-down))
  (defun ig/merge-window-up ()
    (interactive)
    (let ((buffer (window-buffer)))
      (windmove-up)
      (windmove-delete-down)
      (set-window-buffer (selected-window) buffer)))

  (global-set-key (kbd "C-s-<right>") 'ig/split-window-right)
  (global-set-key (kbd "C-s-<left>") 'ig/merge-window-left)
  (global-set-key (kbd "C-s-<down>") 'ig/split-window-down)
  (global-set-key (kbd "C-s-<up>") 'ig/merge-window-up)
  (global-set-key (kbd "s-f") 'delete-other-windows)

  (global-set-key (kbd "M-S-<right>") 'windmove-swap-states-right)
  (global-set-key (kbd "M-S-<left>") 'windmove-swap-states-left)
  (global-set-key (kbd "M-S-<down>") 'windmove-swap-states-down)
  (global-set-key (kbd "M-S-<up>") 'windmove-swap-states-up)
#+end_src

** Custom functions

Random functions I've found on the Internet or have written myself.

#+begin_src emacs-lisp
  (defun xah-change-bracket-pairs (*p1 *p2 *fromType *toType)
    "Change bracket pairs from one type to another on current line or selection.
  For example, change all parenthesis () to square brackets [].

  When called in lisp program, *p1 *p2 are region begin/end position, *fromType or *toType is a string of a bracket pair. ➢ for example: \"()\",  \"[]\", etc.
  URL `http://ergoemacs.org/emacs/elisp_change_brackets.html'
  Version 2015-04-12, modified by IG."
    (interactive
     (let ((-bracketsList
            '("()" "{}" "[]" "<>" "\"\"" "''" "“”" "‘’" "‹›" "«»" "「」" "『』" "【】" "〖〗" "〈〉" "《》" "〔〕" "⦅⦆" "〚〛" "⦃⦄" "〈〉" "⦑⦒" "⧼⧽" "⟦⟧" "⟨⟩" "⟪⟫" "⟮⟯" "⟬⟭" "❛❜" "❝❞" "❨❩" "❪❫" "❴❵" "❬❭" "❮❯" "❰❱")))
       (if (use-region-p)
           (progn (list
                   (region-beginning)
                   (region-end)
                   (completing-read "Replace this:" -bracketsList )
                   (completing-read "To:" -bracketsList )))
         (progn
           (list
            (line-beginning-position)
            (line-end-position)
            (completing-read "Replace this:" -bracketsList )
            (completing-read "To:" -bracketsList ))))))
    (let* (
           (-findReplaceMap
            (vector
             (vector (char-to-string (elt *fromType 0)) (char-to-string (elt *toType 0)))
             (vector (char-to-string (elt *fromType 1)) (char-to-string (elt *toType 1))))))
      (save-excursion
        (save-restriction
          (narrow-to-region *p1 *p2)
          (let ( (case-fold-search nil))
            (mapc
             (lambda (-x)
               (goto-char (point-min))
               (while (search-forward (elt -x 0) nil t)
                 (replace-match (elt -x 1) 'FIXEDCASE 'LITERAL)))
             -findReplaceMap))))))

  (global-set-key (kbd "C-c b") 'xah-change-bracket-pairs)

  (defun ig/save-image-from-clipboard (filepath &optional mimetype)
    "Save an image from clipboard to the `filepath' with type `mimetype',
  or image/png if none provided. Only works on linux."
    (interactive
     (list
      (read-file-name "File to save to:")
      (read-string "Mimetype:" "image/png")))
    (let* ((mimetype (or mimetype "image/png"))
           (command (concat "xclip -selection clipboard -t " mimetype " -o > \"" filepath "\"")))
      (message (concat "Executing " command))
      (shell-command command)))

  (defun ig/paste-image-from-clipboard (folder-to-save-to/)
    "If clipboard contains image, try to save it to the same folder
  the current file is in and return the resulting filepath.
  If clipboard contains image in multiple formats,
  it will pick the first one it finds.
  Returns nil if clipboard doesn't contain any image.
  Uses `ig/save-image-from-clipboard', thus only works on linux."
    (interactive (list (read-directory-name "Save image to folder:")))
    (let* ((clipboard-contents-may-be-symbol (gui-get-selection 'CLIPBOARD 'TARGETS))
           (clipboard-contents (if (sequencep clipboard-contents-may-be-symbol) clipboard-contents-may-be-symbol
                                 `[,clipboard-contents-may-be-symbol])))
      (when (sequencep clipboard-contents)
        (let* ((image-types-list (seq-filter
                                  (lambda (type)
                                    (pcase-let ((`(,major ,minor) (split-string (symbol-name type) "/")))
                                      (if (equal major "image")
                                          type
                                        nil)))
                                  clipboard-contents))
               (image-mimetype (car-safe image-types-list)))
          (when image-mimetype
            (let* ((extension (cond ((eq image-mimetype 'image/png) ".png")
                                    ((or (eq image-mimetype 'image/jpeg) (eq image-mimetype 'image/jpg)) ".jpg")
                                    ((eq image-mimetype 'image/webp) ".webp")
                                    (t "")))
                   (filename (format-time-string (concat "%Y%m%d%H%M%S%3N" extension) (current-time)))
                   (filepath (concat folder-to-save-to/ filename)))
              (ig/save-image-from-clipboard filepath)
              filepath))))))
#+end_src

** Input fixes

Fixes some input annoyances, sometimes may also introduce them.

#+begin_src emacs-lisp
  ;; Enable horizontal scroll (e.g. with touchpad)
  (setq mouse-wheel-tilt-scroll t)

  ;; Do not disable scroll-left
  (put 'scroll-left 'disabled nil)

  ;; Map cyrillic layout to qwerty
  (progn
    (defun map-jtsuken-to-qwerty (jtsuken qwerty pos)
      (when (< pos (length jtsuken))
        (let ((from (aref jtsuken pos))
              (to (aref qwerty pos)))
          (define-key key-translation-map (kbd (concat "C-" (string from))) (kbd (concat "C-" (string to))))
          (define-key key-translation-map (kbd (concat "M-" (string from))) (kbd (concat "M-" (string to)))))
        (map-jtsuken-to-qwerty jtsuken qwerty (+ 1 pos))))

    (map-jtsuken-to-qwerty
     "йцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖ\ЭЯЧСМИТЬБЮ№"
     "qwertyuiop[]asdfghjkl;'zxcvbnm,.QWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>#"
     0)
    )
#+end_src

** Flyspell

Flyspell is the default spell checker in Emacs. This code enables it
and removes "C-;" key binding that conflicts with other bindings I
have.

#+begin_src emacs-lisp
  (use-package flyspell
    :ensure nil
    :hook ((prog-mode . flyspell-prog-mode)
           (text-mode . flyspell-mode))
    :bind (:map flyspell-mode-map
                ("C-;" . nil)))
#+end_src

** Editor behaviour

General fixes for the editor.

#+begin_src emacs-lisp
  ;; Auto-insert bracket pairs
  (setq electric-pair-pairs '(
                              (?\{ . ?\})
                              (?\( . ?\))
                              (?\[ . ?\])
                              (?\" . ?\")
                              ))
  (add-hook 'prog-mode-hook 'electric-pair-local-mode)

  ;; Delete selected region
  (delete-selection-mode 1)

  ;; Enable drag & drop
  (setq mouse-drag-and-drop-region t)

  ;; Move by word in camel and pascal cases
  (add-hook 'prog-mode-hook (lambda () (global-subword-mode 1)))

  ;; UTF-8
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)

  ;; Indentation
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil) ; spaces instead of tabs
  (setq-default standard-indent 4)
  (setq-default electric-indent-inhibit t)
  (setq backward-delete-char-untabify-method 'nil) ; Do not turn tabs into spaces on backspace

  ;; Clickable URLs
  (global-goto-address-mode t)

  ;; Increase undo limit
  (setq undo-limit (* 10 undo-limit))
  (setq undo-strong-limit (* 10 undo-strong-limit))
  (setq undo-outer-limit (* 10 undo-outer-limit))
#+end_src

** Undo/Redo

Default Emacs undo-redo has several limitations. It doesn't store
history for long, will redo when you undo unless you do undo-only,
etc. This piece of code adds [[https://codeberg.org/ideasman42/emacs-undo-fu][Undo-fu]] for convenient undo and redo, and
visual undo ([[https://github.com/casouri/vundo][vundo]]) with tree-like display.

#+begin_src emacs-lisp
  (use-package vundo
    :bind (:map wakib-keys-overriding-map
                ("C-M-z" . vundo))
    :custom
    (vundo-glyph-alist vundo-unicode-symbols))
  (use-package undo-fu
    :defer t)
#+end_src

** Multiple cursors

Adds multi-cursor support. Most useful keybinds are below. Tried to
replicate the ones I'm used to from other editors.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :config
    (global-set-key (kbd "C->") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
    (define-key mc/keymap (kbd "<return>") nil)
    (define-key mc/keymap (kbd "<mouse-1>") 'mc/keyboard-quit)
    (global-unset-key (kbd "M-<down-mouse-1>"))
    (global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click)
    (global-unset-key (kbd "<down-mouse-2>"))
    (global-set-key (kbd "<mouse-2>") 'mc/add-cursor-on-click))
#+end_src

** Dired

Dired is literally an interactive =ls=. =dired-find-alternate-file=
will prevent dired buffers from appearing all over the
place. ~<mouse-1>~ translates to ~<mouse-2>~, and the latter is mapped
to =dired-find-alternate-file=.

Ls-lisp section is needed for sorting folders first, then files.

#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :custom
    (dired-listing-switches "-hal1")
    (delete-by-moving-to-trash t)
    (dired-recursive-deletes 'always)
    (dired-recursive-copies 'always)
    :config
    (put 'dired-find-alternate-file 'disabled nil)
    :hook
    (dired-mode . (lambda ()
                    (local-set-key (kbd "<mouse-2>") #'dired-find-alternate-file))))

  (use-package ls-lisp
    :ensure nil
    :config
    (setq ls-lisp-dirs-first t)
    (setq ls-lisp-use-insert-directory-program nil))
#+end_src

** Org mode

Not exactly "essential", but still convenient to have it configured
here than later in the config. Learn more about [[https://orgmode.org/manual/Structure-Templates.html][structure templates]].

#+begin_src emacs-lisp
  ;; Enable structure templates and add one for elisp code.
  ;; To use, write "<el" in org mode and press tab.
  (with-eval-after-load 'org
    (require 'org-tempo)
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp")))

  ;; Open src edit window (C-d ') fullscreen
  (setq org-src-window-setup 'current-window)

  ;; Add ToC generator
  (use-package toc-org
    :hook ((org-mode markdown-mode) . toc-org-mode))
#+end_src

** Markdown

I like and write markdown a lot. And I don't get the hype for
org-mode, so I use it only for this literate config. Markdown for
everything else.

Emacs is a really nice editing environment for markdown, especially if
you configure it correctly. I've also wrote some functions to paste
images to the same folder the markdown file is in.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode ("README\\.md\\'" . gfm-mode)
    :init (setq markdown-command '("pandoc" "--from=markdown" "--katex" "--to=html5"))
    :custom-face
    (markdown-header-delimiter-face ((t (:inherit markdown-comment-face))))
    (markdown-header-face-1 ((t (:inherit (org-level-1 markdown-header-face) :height 1.8))))
    (markdown-header-face-2 ((t (:inherit (org-level-2 markdown-header-face) :height 1.4))))
    (markdown-header-face-3 ((t (:inherit (org-level-3 markdown-header-face) :height 1.2))))
    (markdown-header-face-4 ((t (:inherit (org-level-4 markdown-header-face) :height 1.15))))
    (markdown-header-face-5 ((t (:inherit (org-level-5 markdown-header-face) :height 1.1))))
    (markdown-header-face-6 ((t (:inherit (org-level-6 markdown-header-face) :height 1.05))))
    :config
    (setq markdown-asymmetric-header t)
    (setq markdown-indent-on-enter 'indent-and-new-item)
    (setq markdown-enable-math t)
    (define-key markdown-mode-map (kbd "C-1") 'markdown-insert-header-atx-1)
    (define-key markdown-mode-map (kbd "C-2") 'markdown-insert-header-atx-2)
    (define-key markdown-mode-map (kbd "C-3") 'markdown-insert-header-atx-3)
    (define-key markdown-mode-map (kbd "C-4") 'markdown-insert-header-atx-4)
    (define-key markdown-mode-map (kbd "C-5") 'markdown-insert-header-atx-5)
    (define-key markdown-mode-map (kbd "C-6") 'markdown-insert-header-atx-6)
    (define-key markdown-mode-map (kbd "C-b") 'markdown-insert-bold)
    (define-key markdown-mode-map (kbd "C-i") 'markdown-insert-italic)
    (define-key markdown-mode-map (kbd "<tab>") 'markdown-cycle)
    (add-hook 'markdown-mode-hook 'visual-line-mode))

  (defun ig/markdown-paste-images-from-clipboard ()
    "Enables support for pasting images from the clipboard.
  Only works on linux. Uses `yank'."
    (interactive)
    (let* ((using-temp-dir (not buffer-file-name))
           (current-folder (if using-temp-dir temporary-file-directory (file-name-directory buffer-file-name)))
           (pasted-image-filepath (ig/paste-image-from-clipboard current-folder)))
      (if pasted-image-filepath
          (if using-temp-dir
              (insert (concat "![](" pasted-image-filepath ")"))
            (insert (concat "![](./" (file-name-nondirectory pasted-image-filepath) ")")))
        (yank))))

  (put 'ig/markdown-paste-images-from-clipboard 'delete-selection 'yank)

  (defvar-keymap ig/markdown-paste-images-map
    :doc "Just remaps yank to custom function."
    "<remap> <yank>" #'ig/markdown-paste-images-from-clipboard)

  (define-minor-mode ig/markdown-paste-images
    "Allows you to paste images in markdown documents, straight from the clipboard.
  Alas, only works on Linux."
    :lighter " MdPasteImg"
    :keymap ig/markdown-paste-images-map)

  (add-hook 'markdown-mode-hook 'ig/markdown-paste-images)
#+end_src

** Magit

A git client, highly recommend. [[https://magit.vc/][Learn more]]. One of the few packages
worth installing Emacs for.

#+begin_src emacs-lisp
  (use-package magit :defer t)

  (use-package magit-todos
    :after (magit)
    :init
    (magit-todos-mode))
#+end_src

** Session management

[[https://github.com/jamescherti/easysession.el][Easysession]] is used to save sessions to files. I think the most
popular alternatives for this kind of things are persp(ective)-mode
and workgroups2, but I couldn't really get used to many features of
perspectives, and while workgroups2 is a really nice package, it can't
save workgroups from multiple instances of emacs because it saves them
all in one file. There are also activities.el which I liked even
better than workgroups, but it suffers from the same
issue. Easysession is the only package that I could find which is easy
enough to use and allows saving sessions from multiple instances,
because every session configuration goes into its own file.

#+begin_src emacs-lisp
  (use-package easysession
    :bind (("C-c C-p" . easysession-switch-to)
           ("C-c C-s" . easysession-save-as))
    :config
    (setq-default frame-title-format
                  '("[|"
                    easysession--current-session-name
                    "|] "
                    "%b"))
    (add-hook 'easysession-after-load-hook #'force-mode-line-update))
#+end_src

** Helpful niceties

[[https://github.com/justbur/emacs-which-key][Which-key]] is a helpful window that pops up when you start pressing
some key chord.
[[https://github.com/radian-software/ctrlf][CTRLF]] is a package that adds proper search.
[[https://github.com/szermatt/emacs-bash-completion][Bash completions]] adds bash-completions to read-shell-command,
which is used by shell-command and async-shell-command, among others.

#+begin_src emacs-lisp
  (use-package which-key
    :defer t
    :init (which-key-mode))

  (use-package ctrlf
    :defer t
    :init (ctrlf-mode +1))

  (use-package bash-completion
    :init
    (autoload
            'bash-completion-dynamic-complete
            "bash-completion"
            "BASH completion hook")
    (add-hook
     'shell-dynamic-complete-functions
     #'bash-completion-dynamic-complete))
#+end_src

** Miscellaneous

Some random emacs configurations.

#+begin_src emacs-lisp
  ;; Relocate backup files
  (setq backup-directory-alist `(("." . "~/.emacs-backups")))
  (setq backup-by-copying t)

  ;; Open bash in ansi-term by default
  (defvar custom-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list custom-term-shell)))
  (ad-activate 'ansi-term)

  ;; Usually if I press F5 I want emacs to compile things;
  ;; I also want to be able to redefine it in some buffers.
  ;; If I put it in wakib-keys, it will take precedence over local bindings.
  (global-set-key (kbd "<f5>") 'compile)

  ;; Show character name on point with C-x =
  (setq what-cursor-show-names t)
#+end_src

* Cosmetic fixes

** General

Making Emacs look better.

#+begin_src emacs-lisp
  ;; Remove scroll bar
  (scroll-bar-mode -1)
  ;; Remove tool bar (the one with big icons)
  (tool-bar-mode -1)

  ;; Highlight current line
  (global-hl-line-mode t)

  ;; Enable line numbers, but only in programming modes
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)

  ;; Enable column number in the mode line
  (column-number-mode 1) 

  ;; Thin cursor in text modes
  (add-hook 'text-mode-hook
            (lambda () (setq cursor-type 'bar)))

  ;; Remove right fringe and enlarge left fringe
  (fringe-mode '(12 . 0))

  ;; Set the strongest scratch buffer on start-up
  (setq initial-scratch-message "\n;;         /*\\           /*\\         \n;;        /---\\_       _/---\\        \n;;        (-\\---\\     /---/-)        \n;;        |--\\-\\-\\___/-/-/--|        \n;;        ]-\\-_--*****--_-/-[        \n;;        ]--/∙∙∙∙∙∙∙∙∙∙∙\\--[        \n;;        >-(∙∙∙∙∙∙∙∙∙∙∙∙∙)-<        \n;;        /_[∙∙∙∙∙∙∙∙∙∙∙∙∙]_\\        \n;;        * [∙∙,^∙∙∙∙∙^.∙∙] *        \n;;         ][∙(__\\_∙_/__)∙][         \n;;         ]\\∙|\\_/ v \\_/|∙/[         \n;;         </\\|    ‿    |/->         \n;;          \\_v--.___.--,^/          \n;;           /-~| >v< |~-_\\          \n;;         -- _\\]*\"-\"*[/_  -         \n;;        (__/-`---------`-_)        \n;;         _/\',~~~.--,/~~.~`\\        \n;;        (∙∙∙__∙∙∙\\/∙∙__∙∙∙)        \n;;        *--(..\\_____/..)--*        \n;;           \\__/     \\__/           \n")
  (setq inhibit-startup-screen t)

  ;; How to construct names to buffers with similar filename
  (setq uniquify-buffer-name-style 'forward)
#+end_src

** Icons

[[https://github.com/domtronn/all-the-icons.el][All the icons]] provides a number of functions that insert various
icons. Some decorative packages require it for their icons. The code
below also adds icons support to dired.

Important: for the icons to actually work, you need to install the
fonts first:

#+begin_example
M-x all-the-icons-install-fonts
#+end_example

#+begin_src emacs-lisp
  (use-package all-the-icons
    :defer t
    :if (display-graphic-p))

  (use-package all-the-icons-dired
    :after (all-the-icons)
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

** Mode line

Also frame title, because they use the same formatting.

The standard GUI scrollbar is inconsistent and looks pretty ugly.
[[https://github.com/jdtsmith/mlscroll][mlscroll]] is a nice lightweight alternative that is actually
interactive and also works in terminals.

[[https://github.com/tarsius/minions][Minions]] hides all minor modes into one little button.

#+begin_src emacs-lisp
  (setq-default frame-title-format '("%b - GNU Emacs"))

  (use-package mlscroll
    :custom
    (mlscroll-in-color "DeepSkyBlue")
    (mlscroll-out-color nil)
    (mlscroll-right-align nil)
    (mlscroll-alter-percent-position 'replace)
    :init
    (mlscroll-mode 1))

  (use-package minions
    :config
    (setq minions-mode-line-lighter "🥞")
    :init
    (minions-mode 1))
#+end_src

** Minibuffer and completion

Here I'm using [[https://github.com/minad][Minad]] stack for minibuffer completion, and consult for
previews when switching to buffers. Although there's a lot of packages
and some have alternatives built in Emacs, they load fast and have
some nice features so it's worth installing them all. Except maybe
consult, because it's large and I only use it for buffer previews.

#+begin_src emacs-lisp
  (use-package vertico
    :init
    (vertico-mode)
    (vertico-mouse-mode)
    :config
    (keymap-set vertico-map "RET" #'vertico-directory-enter)
    (keymap-set vertico-map "DEL" #'vertico-directory-delete-char)
    (keymap-set vertico-map "M-DEL" #'vertico-directory-delete-word)
    (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy))

  (use-package savehist
    :ensure nil
    :init
    (savehist-mode))

  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion))))
    :init
    (define-advice company-capf (:around (orig-fun &rest args) set-completion-styles) 
      (let ((completion-styles '(basic partial-completion orderless)))
        (apply orig-fun args))))

  (use-package marginalia
    :init
    (marginalia-mode))

  (use-package consult
    :bind ([remap switch-to-buffer] . consult-buffer))
#+end_src

** Editing niceties

Most of them really do whatever the name of the package says.
[[https://elpa.gnu.org/packages/rainbow-mode.html][Rainbow mode]] highlights color names with whatever color they are.
[[https://github.com/Fanael/rainbow-delimiters][Rainbow delimiters]] paints brackets to different colours, especially
useful when you're writing lisp. [[https://github.com/joaotavora/darkroom][Darkroom]] is for text modes, for
optional "Zen mode"-like experience.

#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :hook (prog-mode . highlight-indent-guides-mode)
    :config
    (setq highlight-indent-guides-method 'character))

  (use-package hl-todo
    :defer t
    :init
    (global-hl-todo-mode))

  (use-package diff-hl
    :defer t
    :init
    (global-diff-hl-mode)
    :config
    (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))

  (use-package rainbow-mode
    :defer t
    :init
    (add-hook 'prog-mode-hook 'rainbow-mode))

  (use-package rainbow-delimiters
    :defer t
    :init
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

  (use-package darkroom
    :bind (("C-c d" . darkroom-tentative-mode)))
#+end_src

* Themes

** Select light / dark theme based on system theme

I usually just use light theme, but sometimes I enable dark theme
system-wide. To reflect these changes dynamically in Emacs, I use
[[https://github.com/LionyxML/auto-dark-emacs][auto-dark-emacs]].

#+begin_src emacs-lisp
  (use-package auto-dark
    :defer t
    :custom
    (auto-dark-light-theme 'tsdh-light)
    (auto-dark-dark-theme 'modus-vivendi)
    :init (auto-dark-mode t))
#+end_src

* Other packages

** Terminal

Previously, I was using [[https://github.com/akermu/emacs-libvterm][vterm]] for terminal emulation, since it renders
everything pretty good and, when combined with vterm-toggle or custom
functions, provides workflow similar to modern IDEs. However, over
time I grow tired of its handling of user input and overall
UX. Finally, I understood that I primarily use terminal emulator in
emacs to either compile some code (which is better done using built-in
~compile~), or to run some short command (which /can/ be done using
~shell-command~ or its async variant, albeit some commands are using
escape sequences which are not rendered well in emacs buffers).

So at the moment of writing this I mostly use simple emacs functions
for basically everything. And for the rare case when I DO need a
terminal emulator, I'd rather open a real terminal emulator outside of
emacs. I could write a simple function that just calls my preferred
term, but it's better to use a small and portable package called
[[https://github.com/davidshepherd7/terminal-here/][terminal-here]] for this purpose.

Vterm configuration is saved in commit history.

#+begin_src emacs-lisp
  (use-package terminal-here)
#+end_src

** Format on save

[[https://github.com/radian-software/apheleia][Apheleia]] is a nice package that automatically configures formatters
for modes and formats files on save.

#+begin_src emacs-lisp
  (use-package apheleia
    :defer t
    :init
    (apheleia-global-mode +1)
    :config
    (setf (alist-get 'clang-format apheleia-formatters)
          '("clang-format" "-style" "Microsoft" "-assume-filename"
            (or
             (buffer-file-name)
             (apheleia-formatters-mode-extension)
             ".c")))
    (push '(csharpier "dotnet" "csharpier") apheleia-formatters)
    (push '(csharp-mode . csharpier) apheleia-mode-alist))
#+end_src

** Company

[[https://company-mode.github.io/][Company]] is a completion framework. It comes with some configured
backends, but otherwise needs other packages to provide suggestions.
[[https://github.com/company-mode/company-quickhelp][Company quickhelp]] is just a pop-up window for suggestions.

#+begin_src emacs-lisp
  (use-package company :hook (prog-mode . company-mode))

  (use-package company-quickhelp
    :after (company)
    :init (company-quickhelp-mode))
#+end_src

** Flycheck

Syntax checker, a little bit more feature-complete than flymake. [[https://www.flycheck.org/en/latest/][Documentation]].

#+begin_src emacs-lisp
  (use-package flycheck
    :hook (prog-mode . flycheck-mode)
    :config
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+end_src

** Avy

[[https://github.com/abo-abo/avy][Avy]] is a useful package for people who are too lazy to move their
hands away from their keyboard. It allows you to navigate to any point
on screen by calling avy-goto-char, writing the character you want to
move to, and writing some other characters to actually move. All in
all, interesting thing, but usually I'd rather move my right hand onto
the mouse than bother with it.

#+begin_src emacs-lisp
  (use-package avy
    :bind (("C-;" . avy-goto-char)))
#+end_src

** Directory browser

I used Treemacs previously, but it's too heavy for me. Instead, I
found [[https://github.com/jaypei/emacs-neotree][Neotree]], which has minimal dependencies and still works OK.

#+begin_src emacs-lisp
  (use-package neotree
    :bind (("C-b" . neotree-toggle)
           ("C-S-b" . neotree-toggle)
           :map neotree-mode-map
           ("f" . neotree-stretch-toggle)
           ("." . neotree-hidden-file-toggle))
    :config
    (setq neo-theme (if (display-graphic-p) (if (featurep 'all-the-icons) 'icons 'classic) 'arrow)))
#+end_src

** Restclient

A cool mode for writing http requests.

#+begin_src emacs-lisp
  (use-package restclient
    :config
    (defun restclient ()
      "Open the restclient buffer, (re)creating it if not present."
      (interactive)
      (pop-to-buffer (get-buffer-create "*restclient*"))
      (unless (derived-mode-p 'restclient-mode)
        (restclient-mode)))
    :commands
    (restclient))

  (use-package company-restclient
    :after (company restclient)
    :config
    (add-to-list 'company-backends 'company-restclient)
    (add-hook 'restclient-mode 'company-mode))
#+end_src

** Bells and whistles

Some small packages that no one really needs but they're sometimes
cool to have.

#+begin_src emacs-lisp
  ;; M-x fireplace
  (use-package fireplace :defer t)

  ;; Try package without installing it
  ;; M-x try
  (use-package try :defer t)
#+end_src

* Customizations

Put any other customizations into =custom.el= file in the
configuration folder.

If you want to use any specific configuration in this folder, just
include it using function ~ig/load-org-from-user-emacs-directory~ in
your =custom.el=. This function should be defined in =init.el=, it's
used to load this file.

#+begin_src emacs-lisp
  (let ((other-custom-file (expand-file-name "custom.el" user-emacs-directory)))
    (when (file-readable-p other-custom-file) (load other-custom-file)))
#+end_src

* Notes

- To measure (or debug) Emacs startup time, use package ~esup~. To
  install it, use ~try~: ~M-x try esup~ and ~M-x esup~.
- I tried to switch to corfu from company, but I couldn't get it to
  work how I want it to, so decided to stay with company.
